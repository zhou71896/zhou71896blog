---
title: 设计模式4
date: 2018-03-28 17:35:40
tags: 设计模式
categories: 设计模式
---
# 行为型模式
## 责任链模式 (Chain of Responsibility Pattern)
顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。
在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。
介绍
意图:避免请求发送者与接受者耦合在一起，让多个对象都有可能接受请求,将这些对象链接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。
主要解决:职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。
何时使用:在处理消息的时候以过滤很多道。
如何解决:拦截的类实现统一接口。
关键代码:Handler里面聚合它自己，在HanleRequest里判断是否合适，如果没达到条件则向下传递，向谁传递之前set进去。
应用实例:1.红楼梦中的"击鼓传花"。2.JS中的事件冒泡。3.JAVA WEB中Apache Tomcat对Encoding的处理，Structs的拦截器，jsp servlet的Filter
优点:1.降低耦合度，它将请求的发送者和接收者解耦2.简化了对象，使得对象不需要知道链的结构。
2.简化了对象，使得对象不需要知道链的结构。
3.增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态的新增或者删除责任。
4.增加新的请求处理类很方便。
缺点:1. 不能保证请求一定被接收。
2.系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。
3.可能不容易观察运行时的特征，有碍于除错。
使用场景：1.有多个对象可以处理统一个请求，具体哪个对象处理该请求由运行时刻自动确定。2.在不明确指定接受者的情况下，向多个对象中的一个提交一个请求。3.可动态指定一组对象处理请求。
注意事项：在JAVA WEB中遇到很多应用。
实现
我们创建抽象类 AbstractLogger，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 AbstractLogger。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。
步骤1
创建抽象的记录器类。
AbstactLogger.java
{% codeblock lang:java %}
pulbic abstact class AbstactLogger{
	public static int INFO =1;
	public static int DEBUG=2;
	public static int ERROR=3;
	protected int level;
	
	//责任链中的下一个元素
	protected AbstactLogger nextLogger;
	
	public void setNextLogger(AbstractLogger nextLogger){
		this.nextLogger=nextLogger;
	}
	
	public void logMessage(int level,String message){
		if(this.level<=level){
			write(message);
		}
		if(nextLogger != null){
			nextLogger.logMessage(level,message);
		}
	}
	abstact  protected void write(String message);
}
{% endcodeblock %}
步骤2
创建扩展了该记录器类的实体类。
ConsoleLogger.java
{% codeblock lang:java %}
public class ConsoleLogger extends AbstactLogger{
	public ConsoleLogger(int level){
		this.level=level;
	}
	@Override
	protected void write(String message){
		System.out.println("Standard Console::Logger: "+message);
	}
}
{% endcodeblock %}
ErrorLogger.java
{% codeblock lang:java %}
public class ErrorLogger extends AbstactLogger{
	public ErrorLogger(int level){
		this.level=level;
	}
	@Override
	protected void write(String message){
		System.out.println("Error Console::Logger: "+message);
	}
}
{% endcodeblock %}
FileLogger.java
{% codeblock lang:java %}
public class FileLogger extends AbstactLogger{
	public FileLogger(int level){
		this.level=level;
	}
	@Override
	protected void write(String message){
		System.out.println("File:Logger: "+message);
	}
}
{% endcodeblock %}
步骤3
创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。
ChainPatternDemo.java
{% codeblock lang:java %}
public class ChainPatternDemo{
	private static AbstactLogger getChainOfLoggers(){
		AbstactLogger errorLogger=new ErrorLogger(AbstactLogger.ERROR);
		AbstactLogger fileLogger=new FileLogger(AbstactLogger.DEBUG);
		AbstactLogger consoleLogger=new ConsoleLogger(AbstactLogger.INFO);
		errorLogger.setNextLogger(fileLogger);
		fileLogger.setNextLogger(consoleLogger);
		return errorLogger;
	}
	public static void main(String[] args){
		AbstactLogger loggerChain=getChainOfLoggers();
		loggerChain.logMessage(AbstactLogger.INFO,"This is an information.");
		loggerChain.logMessage(AbstactLogger.DEBUG,"This is an debug level information.");
		loggerChain.logMessage(AbstactLogger.ERROR,"This is  an error information.");
	}
}
{% endcodeblock %}
## 命令模式 (Command Pattern)
命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。
介绍
意图:将一个请求封装成一个对象，从而使您可以用不同的请求客户进行参数化。
主要解决:在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录，撤销或重做，事务等处理时，这种无法抵制变化的紧耦合的设计就不太合适。
进行记录,撤销或重做，事务等处理时，这种无法抵制变化的紧耦合的设计不太合适。
何时使用:在某些场合，比如要对行为进行"记录，撤销、重做事务"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。
如何解决:通过调用者调用接受者执行命令，顺序：调用者->接受者->命令。
关键代码:定义三个角色：
1.received真正的命令执行对象
2.Command
3.invoker使用命令对象的入口
应用实例:structs1中action核心控制器ActionServlet只有一个，相当于Invoker,而模型层的类会随着不同的应用有不同的模型类，相当于具体的Command。
优点:1.降低了系统耦合度。
2.新的命令可以很容易添加到系统中去。
缺点: 使用命令模式可能会导致某些系统有过多的具体命令类。
使用场景:认为是命令的地方都可以使用命令模式，比如：1.GUI中每一个按钮都是一条命令。2模拟CMD
注意事项: 系统需要支持命令的撤销操作和回复操作，也可以考虑使用命令模式，见命令模式的扩展。
实现
我们首先创建作为命令的接口Order,然后创建作为请求的Stock类，实体命令类BuyStock和ShellStock,实现了Order接口,将执行实际的命令处理。创建作为调用对象的类Broker,它接受订单并能下订单。
Broker对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。CommandPatternDemo,我们的演示类使用Broker类来演示命令模式。
步骤1
创建一个命令接口。
Order.java
{% codeblock lang:java %}
public interface Order{
	void execute();
}
{% endcodeblock %}
步骤2
创建一个请求类
Stock.java
{% codeblock lang:java %}
public class Stock{
	private String name="ABC"
	private int quantity=10;
	public void buy(){
		System.out.println("Stock[Name: "+name+"Quantity: "+quantity);
	}
	public void sell(){
		System.out.println("Stock[Name: "+name+",Quantity: "+quantity);
	}

}
{% endcodeblock %}
步骤3
创建实现了Order接口的实体类
BuyStock.java
{% codeblock lang:java %}
public class BuyStock implements Order{
	private Stock abcStock;
	public BuyStock(Stock abcStock){
		this.abcStock=abcStock;
	}
	public void execute(){
		abcStock.sell();
	}

}
{% endcodeblock %}
步骤4
创建命令调用类
Broker.java
{% codeblock lang:java %}
import java.util.ArrayList;
import java.util.List;
pulbic class Broker{
	private List<Order> orderList=new ArrayList<Order>();
	public void takeOrder(Order order){
		orderList.add(order);
	}
	public void placeOrders(){
		for(Order order : orderList){
			order .execute();
		}
		orderList.clear();
	}

}
{% endcodeblock %}
步骤5
使用Broker类来接收并执行命令。
CommandPatternDemo.java
{% codeblock lang:java %}
public class CommandPatternDemo{
	public static void main(String[] args){
		Stock abcStock=new Stock();
		BuyStock buyStockOrder=new BuyStock(abcStock);
		SellStock sellStockOrder=new SellStock(abcStock);
		Broker broker=new Broker();
		broker.takeOrder(buyStockOrder);
		broker.takeOrder(sellStockOrder);
		broker.placeOrders();
	}
}
{% endcodeblock %}
## 解释器模式(Interpreter Pattern)
解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。
介绍
主要解决:对于一些固定文法构建一个解释句子的解释器。
何时使用: 如果一种待定类型的问题发生频率足够高，那么可能就值得该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。
何时解决:构建语法树，定义 终结符与非终结符。
关键代码:构建环境类，包含解释器之外的一些全局信息，一般是HashMap。
应用实例: 编译器，运算表达式计算。
优点: 1.可扩展性比较好，灵活。 2.增加了新的解释表达式的方式。 3.易于实现简单文法。
缺点: 1.可利用场景比较少。 2.对复杂的文法比较难维护。3.解释器模式会引起类膨胀。4.解释器模式采用递增调用方法。
使用场景: 1.可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。2.一些重复出现的问题可以用一种简单的语音来进行表达。3.一个简单语法需要解释的场景。
注意事项:可利用场景比较少，Java中如果碰到可以用expression4j代替。
实现
我们将创建一个接口Expression和实现了Expression接口的实体类。定义作为上下文中主要解释器的TerminalExpression类，其他 的类OrExpression,AndExpression用于创建组合表达式。
InterpreterPatternDemo,我们的演示类使用Expression类创建规则和演示表达式的解析。
步骤1
创建一个表达式接口
Expression.java
{% codeblock lang:java %}
public interface Expression{
	public boolean interpret(String context);
}
{% endcodeblock %}
步骤2
创建实现了上述接口的实体类。
TerminalExpression.java
{% codeblock lang:java %}
public class TerminalExpression implements Expression{
	private String data;
	public TerminalExpression(String data){
		this.data=data;
	}
	@Override
	public boolean interpret(String context){
		if(context.contains(data)){
			return true;
		}
		return false;
	}
}
{% endcodeblock %}
OrExpression.java
{% codeblock lang:java %}
public class OrExpression implements Expression {
     
   private Expression expr1 = null;
   private Expression expr2 = null;

   public OrExpression(Expression expr1, Expression expr2) { 
      this.expr1 = expr1;
      this.expr2 = expr2;
   }

   @Override
   public boolean interpret(String context) {        
      return expr1.interpret(context) || expr2.interpret(context);
   }
}
{% endcodeblock %}
AndExpression.java
{% codeblock lang:java %}
public class AndExpression implements Expression {
     
   private Expression expr1 = null;
   private Expression expr2 = null;

   public AndExpression(Expression expr1, Expression expr2) { 
      this.expr1 = expr1;
      this.expr2 = expr2;
   }

   @Override
   public boolean interpret(String context) {        
      return expr1.interpret(context) && expr2.interpret(context);
   }
}
{% endcodeblock %}
步骤3
InterpreterPatternDemo 使用 Expression 类来创建规则，并解析它们。
InterpreterPatternDemo.java
{% codeblock lang:java %}
public class InterpreterPatternDemo{
	//规则：Robert和John是男性
	public static Expression  getMaleExpression(){
		Expression robert=new TerminalExpression("Jule");
		Expression married=new TerminalExpression("Married");
		return new AndExpression(julie,married);
	}
	public static void main(String[] args){
		Expression isMale=getMaleExpression();
		Expression isMarriedWoman=getMarriedWomanExpression();
		System.out.println("John is name?"+isMale.interpret("John"));
		System.out.println("Julie is a married woman?"+isMarriedWoman.interpret("Married  Julie"));
	}
}
{% endcodeblock %}
## 迭代器模式(Iterator Pattern)
迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。
迭代器模式属于行为型模式。
介绍
意图:提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。
主要解决:不同的方式来遍历整个整合对象。
如何使用:遍历一个聚合对象。
如何解决:把在元素之间游走的责任交给迭代器，而不是聚合对象。
关键代码:定义接口：hasNext,next。
应用实例:Java中的iterator
优点: 1.它支持以不同的方式遍历一个聚合对象。2.迭代器简化了聚合类。3.在同一个聚合上可以有多个遍历。4.在迭代模式中，增加新的聚合类和迭代类都很方便，无须修改原有代码。
缺点: 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。
使用场景: 1.访问一个聚合对象的内容而无须暴露它的内部表示。2.需要为聚合对象提供多种遍历方式。3.为遍历不同的聚合结构提供一个统一的接口。
注意事项: 迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。
实现
我们将创建一个叙述导航方法的Iterator接口和一个返回迭代器的Container接口。实现了Container接口的实体类将负责实现iterator接口。

## 中介者模式(Meidator Pattern)

## 备忘录模式(Memento Pattern)

## 观察者模式(Observer Pattern)

## 状态模式(State Pattern)

## 空对象模式(Null Object Pattern)

## 策略模式(Strategy Pattern)

## 模板模式(Template Pattern)

## 访问者模式(Visitor Pattern)